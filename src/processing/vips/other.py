import random
from statistics import mean

import pyvips

import processing.ffmpeg.ffprobe
import processing.vips.vipsutils
from processing.common import run_parallel, NonBugError, image_format
from processing.ffmpeg.conversion import mediatopng
from processing.vips.vipsutils import normalize
from utils.tempfiles import reserve_tempfile, TempFile


def get_caption_height(file, tolerance: float):
    im = normalize(pyvips.Image.new_from_file(file))
    h = im.height  # height of image, fuckin weird name
    # based on old esmbot approach, the new one looks weird
    target = 255
    for row in range(h):
        px = im.getpoint(0, row)
        if mean([abs(target - bandval) for bandval in px]) > tolerance:
            return row + 1
    raise NonBugError("Unable to detect caption. Try to adjust `frame_to_try`. Run `$help uncaption` for help.")


async def uncaption(file, frame_to_try: int, tolerance: float):
    frame_to_try = await mediatopng(await processing.ffmpeg.ffprobe.frame_n(file, frame_to_try))
    cap_height = await run_parallel(get_caption_height, frame_to_try, tolerance)
    return await processing.ffmpeg.ffutils.trim_top(file, cap_height)


def jpeg(file: TempFile, strength: int, stretch: list[tuple[int, int]] | None, quality: int):
    """
    repeatedly jpeg compress an image, optionally resizing it each time to simulate reposting
    :param file: input file
    :param strength: how many times to compress
    :param stretch: a list of how much to stretch by each time, generated by processing.ffmpeg.other.handle_jpeg
    :param quality: the JPEG quality per compression
    """
    do_stretching = stretch is not None
    im = normalize(pyvips.Image.new_from_file(file))
    orig_w = im.width
    orig_h = im.height
    for i in range(strength):
        if do_stretching:
            # resize to anywhere between (original image width ± stretch, original image height ± stretch)
            # simulates being reposted many times
            im = processing.vips.vipsutils.resize(im, orig_w + stretch[i][0], orig_h + stretch[i][1])
        # save to jpeg and read back to image
        im = pyvips.Image.jpegload_buffer(im.jpegsave_buffer(Q=quality))
    if do_stretching:
        # resize back to original size
        im = processing.vips.vipsutils.resize(im, orig_w, orig_h)
    # save
    outfile = reserve_tempfile(image_format)
    im.write_to_file(outfile)
    return outfile

